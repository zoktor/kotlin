package org.jetbrains.kotlin.tools

import java.io.File
import org.w3c.dom.Element
import kotlin.dom.parseXml
import kotlin.dom.iterator
import java.io.FileOutputStream
import org.w3c.dom.Node
import java.util.HashMap
import java.util.HashSet

private fun Element.attribute(name: String): String? {
    val value = getAttribute(name)!!
    return if (value.isEmpty()) null else value
}

fun generateApi(packageName: String, idlFile: File, outFile: File) {
    val generator = JavaScriptStubGenerator(packageName)
    generator.generate(idlFile)
    generator.writeTo(outFile)
}

class JavaScriptStubGenerator(packageName: String) {
    private val builder = StringBuilder("//\n// NOTE THIS FILE IS AUTO-GENERATED by the GenerateJavaScriptStubs.kt\n//\n\npackage $packageName")
    private val classNameToEndOffset = HashMap<String, Int>()
    private val propertyDuplicateGuard = HashSet<String>()

    private var currentClassName: String? = null

    private fun findConstructor(classElement: Element): Element? {
        for (val node in classElement.getChildNodes()!!) {
            if (node is Element && node.getTagName() == "method" && node.getAttribute("name") == "__constructor__") {
                return node
            }
        }
        return null
    }

    fun generate(idlFile: File) {
        val document = parseXml(idlFile)
        for (val node in document.getDocumentElement()!!.iterator().filter { it is Element && it.getTagName() == "class" }) {
            val element = node as Element
            currentClassName = element.attribute("name")!!

            val endOffset = classNameToEndOffset.get(currentClassName)
            val builder: StringBuilder
            if (endOffset == null) {
                builder = this.builder
                builder.append("\n\npublic native trait ").append(currentClassName)
                val constructor = findConstructor(element)
                if (constructor != null) {

                }


                val extends = element.attribute("extends")
                if (extends != null) {
                    builder.append(" : ").append(extends)
                }
                builder.append(" {")
            }
            else {
                builder = StringBuilder()
                builder.append("\n")
            }

            val static = element.iterator().filter { it is Element && it.getTagName() == "static" }
            val hasStaticMemebers = static.hasNext()
            if (hasStaticMemebers) {
                builder.append("\n\tpublic class object {")
                processMembers(static.next() as Element, true, false, "\t\t", builder)
                builder.append("\n\t}")

                assert(!static.hasNext())
            }
            processMembers(element, false, hasStaticMemebers, "\t", builder)

            if (endOffset == null) {
                classNameToEndOffset.put(currentClassName!!, builder.length)
                builder.append("\n}")
            }
            else {
                this.builder.insert(endOffset, builder)
            }
        }
        currentClassName = null
    }

    fun writeTo(outFile: File) {
        val outStream = FileOutputStream(outFile)
        outStream.write(builder.toString().getBytes());
        outStream.close()
    }

    private fun checkElement(element: Node, tagName: String) = element is Element && element.getTagName() == tagName && element.attribute("deprecated") == null

    fun processMembers(element: Element, static: Boolean, hasMembersBefore: Boolean, indent: String, builder: StringBuilder) {
        val nodes = element.getChildNodes()!!
        val properties = nodes.iterator().filter { checkElement(it, "property") && propertyDuplicateGuard.add(currentClassName + "." + (it as Element).attribute("name")!!) }
        val methods = nodes.iterator().filter { checkElement(it, "method") }
        val insertNewLineSeparator = properties.hasNext() && methods.hasNext()

        if (hasMembersBefore && (properties.hasNext() || methods.hasNext())) {
            builder.append('\n')
        }

        processProperties(properties, indent, builder)
        if (insertNewLineSeparator) {
            builder.append('\n')
        }
        processMethods(methods, static, indent, builder)
    }

    private fun processProperties(nodes: Iterator<Node>, indent: String, builder: StringBuilder) {
        for (val node in nodes) {
            val element = node as Element
            builder.append("\n${indent}public va")
            val readOnly = element.attribute("readOnly") == "true" || element.getAttribute("attribute")!!.equalsIgnoreCase("readonly")
            builder.append(if (readOnly) 'l' else 'r')
            builder.append(' ').append(getName(element)).append(": ").append(getType(element))

            val value = element.attribute("value")
            if (value != null) {
                builder.append(" = ").append(value)
            }
        }
    }

    private fun processMethods(nodes: Iterator<Node>, bodyRequired: Boolean, indent: String, builder: StringBuilder) {
        for (val node in nodes) {
            val element = node as Element
            val name = getName(element)
            if (name == "__constructor__") {
                continue
            }

            builder.append("\n${indent}public fun ").append(name).append('(')
            for (val paramNode in element.getChildNodes()!!) {
                val paramElement = paramNode as? Element
                if (paramElement == null) {
                    continue
                }

            }
            builder.append("): ").append(getType(element, "returnType"))
            if (bodyRequired) {
                builder.append(" = ").append("noImpl")
            }
        }
    }

    private fun getName(element: Element): String {
        val name = element.getAttribute("name")!!
        return when (name) {
            "type" -> "`type`"
            else -> name
        }
    }

    private fun getType(element: Element, attributeName: String = "type"): String {
        val typeName = element.attribute(attributeName)
        return when (typeName) {
            "long" -> "Long"
            "int" -> "Int"
            "byte" -> "Byte"
            "void", null -> "Unit"
            "Function" -> "()->Unit"
            "Array" -> "Array<Any>"
            "Object", "*" -> "Any"
            "\$__Type__$" -> currentClassName!!
            else -> {
                if (typeName.endsWith("[]")) {
                    "Array<${typeName.substring(0, typeName.length - 2)}>"
                }
                else {
                    typeName
                }
            }
        }
    }
}